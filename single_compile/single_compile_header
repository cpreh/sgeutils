#!/bin/bash

set -o nounset
set -o errexit

readonly header_pattern="*.hpp"
readonly search_directories="src include"
readonly number_of_files=$(find $search_directories -type f -name "$header_pattern" | wc -l)
readonly exclusion_patterns=( "/impl/" )
readonly build_dir_name="sgebuild_compile_headers"

# Outputting \r moves the cursor to the beginning of the line.
# However, if the next line is shorter than the line before, garbage remains.
# For example:
#
# foobarbaz\rlol
#
# Will result in
#
# lolbarbaz
#
# To clear the whole line, we issue a control code after the carriage return.
# Source:
# http://stackoverflow.com/questions/2388090/how-to-delete-and-replace-last-line-in-the-terminal-using-bash
function pimiddy_carriage_return_with_clear()
{
	echo -en "\r\033[K"
}

function pimiddy_absolutize_file_name()
{
	readlink -f "$1"
}

current_file_number=0

# Read the output of "find" line by line
while IFS= read -r -d $'\0' file; do

	current_file_number=$((current_file_number+1));
	readonly absolute_file_name=$(pimiddy_absolutize_file_name "${file}")
	# For an optional percent display
	readonly percent=$(( current_file_number * 100 / number_of_files ))

	pimiddy_carriage_return_with_clear
	echo -n "[$current_file_number/$number_of_files] "

	skip_this_file="0"
	for current_exclusion_pattern in ${exclusion_patterns[@]}; do
		if [[ $absolute_file_name =~ $current_exclusion_pattern ]]; then
			echo -n "Skipping $absolute_file_name"
			skip_this_file="1"
			break;
		fi
	done

	if [[ $skip_this_file == 1 ]]; then
		continue
	fi

	echo -n "Testing $absolute_file_name"

	if ! single_compile_output=$(single_compile --syntax-only --build-dir-name=${build_dir_name} --file-name="${absolute_file_name}" 2>&1); then
		echo ""
		echo "$single_compile_output"
	fi

done < <(find $search_directories -name "$header_pattern" -type f -print0)

